

java 8大类型

byte short int long boolean char float  double

192.168.1.101
自定义注解说明：

Java使用@interface定义注解：
可定义多个参数和默认值，核心参数使用value名称；
必须设置@Target来指定Annotation可以应用的范围；
应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。






Reader定义了所有字符输入流的超类：
    FileReader实现了文件字符流输入，使用时需要指定编码；
    CharArrayReader和StringReader可以在内存中模拟一个字符流输入。
Reader是基于InputStream构造的：可以通过InputStreamReader在指定编码的同时将任何InputStream转换为Reader。
总是使用try (resource)保证Reader正确关闭。




Writer定义了所有字符输出流的超类：
    FileWriter实现了文件字符流输出；
    CharArrayWriter和StringWriter在内存中模拟一个字符流输出。
使用try (resource)保证Writer正确关闭。
Writer是基于OutputStream构造的，可以通过OutputStreamWriter将OutputStream转换为Writer，转换时需要指定编码。

PrintStream是一种能接收各种数据类型的输出，打印数据时比较方便：
    System.out是标准输出；
    System.err是标准错误输出。
PrintWriter是基于Writer的输出。





在编写日期和时间的程序前，我们要准确理解日期、时间和时刻的概念。
由于存在本地时间，我们需要理解时区的概念，并且必须牢记由于夏令时的存在，同一地区用GMT/UTC和城市表示的时区可能导致时间不同。
计算机通过Locale来针对当地用户习惯格式化日期、时间、数字、货币等。
计算机表示的时间是以整数表示的时间戳存储的，即Epoch Time，Java使用long型来表示以毫秒为单位的时间戳，通过System.currentTimeMillis()获取当前时间戳。



Java有两套日期和时间的API：
    旧的Date、Calendar和TimeZone；
    新的LocalDateTime、ZonedDateTime、ZoneId等。
分别位于java.util和java.time包中。




ZonedDateTime是带时区的日期和时间，可用于时区转换；
ZonedDateTime和LocalDateTime可以相互转换。



对ZonedDateTime或LocalDateTime进行格式化，需要使用DateTimeFormatter类；
DateTimeFormatter可以通过格式化字符串和Locale对日期和时间进行定制输出。
Instant表示高精度时间戳，它可以和ZonedDateTime以及long互相转换。


JUnit是一个单元测试框架，专门用于运行我们编写的单元测试：
一个JUnit测试包含若干@Test方法，并使用Assertions进行断言，注意浮点数assertEquals()要指定delta。


编写Fixture是指针对每个@Test方法，编写@BeforeEach方法用于初始化测试资源，编写@AfterEach用于清理测试资源；
必要时，可以编写@BeforeAll和@AfterAll，使用静态变量来初始化耗时的资源，并且在所有@Test方法的运行前后仅执行一次。

测试异常可以使用assertThrows()，期待捕获到指定类型的异常；

使用参数化测试，可以提供一组测试数据，对一个测试方法反复测试。
参数既可以在测试代码中写死，也可以通过@CsvFileSource放到外部的CSV文件中。


maven 基础命令
    mvn clean
    mvn clean compile
    mvn clean test
    mvn clean package
    mvn clean install



lambda表达式

FunctionalInterface允许传入：

    接口的实现类（传统写法，代码较繁琐）；
    Lambda表达式（只需列出参数名，由编译器推断类型）；
    符合方法签名的静态方法；
    符合方法签名的实例方法（实例类型被看做第一个参数类型）；
    符合方法签名的构造方法（实例类型被看做返回类型）。

创建Stream的方法有 ：
    通过指定元素、指定数组、指定Collection创建Stream；
    通过Supplier创建Stream，可以是无限序列；
    通过其他类的相关方法创建。
基本类型的Stream有IntStream、LongStream和DoubleStream。


设计模式（分为3种模式  创建型模式   结构性模式  行为型模式）
创建型模式
        工厂方法  Factory Method
        抽象工厂  Abstract Factory
        建造者    Builder
        原型      ProtoType
        单例      Singleton

        工厂方法  Factory Method
            工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。
            实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。
            调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。

        抽象工厂  Abstract Factory
            抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；
            抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。


结构性模式
行为型模式









