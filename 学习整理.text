

java 8大类型

byte short int long boolean char float  double

192.168.1.101
自定义注解说明：

Java使用@interface定义注解：
可定义多个参数和默认值，核心参数使用value名称；
必须设置@Target来指定Annotation可以应用的范围；
应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。






Reader定义了所有字符输入流的超类：
    FileReader实现了文件字符流输入，使用时需要指定编码；
    CharArrayReader和StringReader可以在内存中模拟一个字符流输入。
Reader是基于InputStream构造的：可以通过InputStreamReader在指定编码的同时将任何InputStream转换为Reader。
总是使用try (resource)保证Reader正确关闭。




Writer定义了所有字符输出流的超类：
    FileWriter实现了文件字符流输出；
    CharArrayWriter和StringWriter在内存中模拟一个字符流输出。
使用try (resource)保证Writer正确关闭。
Writer是基于OutputStream构造的，可以通过OutputStreamWriter将OutputStream转换为Writer，转换时需要指定编码。

PrintStream是一种能接收各种数据类型的输出，打印数据时比较方便：
    System.out是标准输出；
    System.err是标准错误输出。
PrintWriter是基于Writer的输出。





在编写日期和时间的程序前，我们要准确理解日期、时间和时刻的概念。
由于存在本地时间，我们需要理解时区的概念，并且必须牢记由于夏令时的存在，同一地区用GMT/UTC和城市表示的时区可能导致时间不同。
计算机通过Locale来针对当地用户习惯格式化日期、时间、数字、货币等。
计算机表示的时间是以整数表示的时间戳存储的，即Epoch Time，Java使用long型来表示以毫秒为单位的时间戳，通过System.currentTimeMillis()获取当前时间戳。



Java有两套日期和时间的API：
    旧的Date、Calendar和TimeZone；
    新的LocalDateTime、ZonedDateTime、ZoneId等。
分别位于java.util和java.time包中。




ZonedDateTime是带时区的日期和时间，可用于时区转换；
ZonedDateTime和LocalDateTime可以相互转换。



对ZonedDateTime或LocalDateTime进行格式化，需要使用DateTimeFormatter类；
DateTimeFormatter可以通过格式化字符串和Locale对日期和时间进行定制输出。
Instant表示高精度时间戳，它可以和ZonedDateTime以及long互相转换。


JUnit是一个单元测试框架，专门用于运行我们编写的单元测试：
一个JUnit测试包含若干@Test方法，并使用Assertions进行断言，注意浮点数assertEquals()要指定delta。


编写Fixture是指针对每个@Test方法，编写@BeforeEach方法用于初始化测试资源，编写@AfterEach用于清理测试资源；
必要时，可以编写@BeforeAll和@AfterAll，使用静态变量来初始化耗时的资源，并且在所有@Test方法的运行前后仅执行一次。

测试异常可以使用assertThrows()，期待捕获到指定类型的异常；

使用参数化测试，可以提供一组测试数据，对一个测试方法反复测试。
参数既可以在测试代码中写死，也可以通过@CsvFileSource放到外部的CSV文件中。


maven 基础命令
    mvn clean
    mvn clean compile
    mvn clean test
    mvn clean package
    mvn clean install



lambda表达式

FunctionalInterface允许传入：

    接口的实现类（传统写法，代码较繁琐）；
    Lambda表达式（只需列出参数名，由编译器推断类型）；
    符合方法签名的静态方法；
    符合方法签名的实例方法（实例类型被看做第一个参数类型）；
    符合方法签名的构造方法（实例类型被看做返回类型）。

创建Stream的方法有 ：
    通过指定元素、指定数组、指定Collection创建Stream；
    通过Supplier创建Stream，可以是无限序列；
    通过其他类的相关方法创建。
基本类型的Stream有IntStream、LongStream和DoubleStream。


设计模式（分为3种模式  创建型模式   结构性模式  行为型模式）
创建型模式
        工厂方法  Factory Method
        抽象工厂  Abstract Factory
        建造者    Builder
        原型      ProtoType
        单例      Singleton

        工厂方法  Factory Method
            工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。
            实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。
            调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。

        抽象工厂  Abstract Factory
            抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；
            抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。

        生成器模式 Builder
             将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
             生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。
             当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。

        原型模式  prototype
            用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
            原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。

        单例     singleton
            单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。
            因为这个类只有一个实例，因此，自然不能让调用方使用new Xyz()来创建实例了。所以，单例的构造方法必须是private，这样就防止了调用方自己创建实例，
            但是在类的内部，是可以用一个静态字段来引用唯一创建的实例的：
            所以，单例模式的实现方式很简单：
            只有private构造方法，确保外部无法实例化；
            通过private static变量持有唯一实例，保证全局唯一性；
            通过public static方法返回此唯一实例，使外部调用方能获取到实例。
            Singleton模式是为了保证一个程序的运行期间，某个类有且只有一个全局唯一实例；
            Singleton模式既可以严格实现，也可以以约定的方式把普通类视作单例。

结构性模式
        适配器     Adapter
        桥接
        组合
        装饰器
        外观
        享元
        代理

行为型模式









